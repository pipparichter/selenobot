'''Code for searching for analyzing results of MMSeqs2 homology search.'''
import os
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import copy
from typing import NoReturn, List, Tuple, Dict
import re
import subprocess
from tqdm import tqdm
import seaborn as sns
import requests


DATA_DIR = '/home/prichter/Documents/data/selenobot/validation/homology/'

def ncbi_blast_download_sequence_data() -> NoReturn:
    '''Download the sequence data for each accession in the blast hits, and write the results to a CSV file.
    Also clean up the format of the BLAST results.'''
    dir_path = os.path.join(DATA_DIR, 'ncbi_blast')
    
    dfs = []
    for filename in os.listdir(dir_path):
        if 'control' not in filename: # Don't deal with the controls for now. 
            df = pd.read_csv(os.path.join(dir_path, filename), delimiter='\t')
            df['query_gene_id'] = filename[:4]
            dfs.append(df)
    data = pd.concat(dfs) 
    data.columns = [re.sub('\(.*\)', '', col.lower()) for col in data.columns]

    # Download the amino acid sequences from UniProt.
    seqs = []
    for acc in data.accession: 
        fasta = requests.get(f'https://rest.uniprot.org/uniprotkb/{acc}.fasta').text.strip()
        print(f'main.ncbi_blast_download_sequence_data: Downloaded sequence for accession {acc}.')
        # Remove the FASTA header. 
        seq = ''.join(fasta.split('\n')[1:])
        seqs.append(seq)
    data['seq'] = seqs

    # Write the resulting DataFrame.
    data.to_csv(os.path.join(DATA_DIR, 'ncbi_blast.csv'))


def load_ncbi_blast() -> pd.DataFrame:
    '''Read in the DataFrame generated by ncbi_download_sequence_data.'''
    path = os.path.join(DATA_DIR, 'ncbi_blast.csv')
    return pd.read_csv(path, index_col=0)


def load_mmseqs(dir_path) -> pd.DataFrame:
    '''Load the BLAST hit results from the search of GTDB into a pandas DataFrame. BLAST result files (file extension m8)
    are tab-separated, with no column headers.'''

    # Columns in the output file, as specified in the MMSeqs2 User Guide. 
    cols = ['header', 'target_gene_id', 'seq_identity', 'alignment_length', 'num_mismatches', 'num_gap_openings', 'query_domain_start', 'query_domain_stop', 'target_domain_start', 'target_domain_stop', 'e_value', 'bit_score']

    def parse_headers(headers:pd.Series) -> pd.DataFrame:
        rows = []
        for header in headers:
            header = dict([item.split('=') for item in header.split('|')])
            # Don't need all of the information contained in the header... 
            header = {key:val for key, val in header.items() if key in ['gene_id', 'aa_length', 'nt_ext']}
            header['aa_ext'] = int(header['nt_ext']) // 3 # Get the number of added amino acids. 
            header = {'query_' + key:val for key, val in header.items()} # Clarify that all header information is associated with the query sequence.
            rows.append(header)
        return pd.DataFrame(rows, index=np.arange(len(headers)))


    # NOTE: Requiring the hit to SPAN the stop codon does not seem to make a difference. 
    def label_hits_past_stop_codon(data:pd.DataFrame, require_span:bool=True) -> pd.DataFrame: #, remove_query_gene_ids:List[str]=[]) -> pd.DataFrame:
        '''Find instances where a domain match is found past the first stop codon. The aa_length column gives the length of the
        extended amino acid sequence (if an extension was applied), so the stop codon location can be computed by subtracting the aa_ext
        from the length.
        
        :param data: The DataFrame containing the BLAST hits for the query sequences against GTDB.
        :param require_span: Whether or not to only include hits which span the U codon (not just in the region to the right of it).
        :return: A DataFrame which contains the hits which meet the parameter specifications. 
        '''
        if require_span: 
            # Make sure the beginning of the matching domain is to the left of the putative U position, AND the end of the match is to the right.
            data['past_stop_codon'] = (data.query_domain_start <= data.query_u_position) & (data.query_domain_stop >= data.query_u_position)
        else: # Filter by locations where the end of the matching domain in the query sequence is found past the extension.
            data['past_stop_codon'] = data.query_domain_stop >= data.query_u_position
        return data 

    data = []
    for filename in os.listdir(dir_path):
        # Grab the number of the split from the filename. 
        split = int(re.match('([0-9]+)', filename).group(1))
        split_data = pd.read_csv(os.path.join(dir_path, filename), delimiter='\t', names=cols)
        split_data = pd.concat([split_data.drop(columns=['header']), parse_headers(split_data.header)], axis=1)
        split_data['split'] = split # Add the target database split where the BLAST hit was found.
        data.append(split_data)

    data = pd.concat(data, axis=0)
    # Convert the columns which are numbers to numerical columns. Only the query and target gene_ids are not numerical
    num_cols = [col for col in data.columns if 'gene_id' not in col]
    data[num_cols] = data[num_cols].apply(pd.to_numeric)

    # Compute the location of the posited U residue. 
    data['query_u_position'] = data.query_aa_length - data.query_aa_ext
    data = label_hits_past_stop_codon(data)

    # Remove the things we know to be false positives. 
    data = data[~data.query_gene_id.isin(['ilvB', 'ivbL'])]

    return data


def mmseqs_summarize() -> NoReturn:
    '''Summarize some results from the MMSeqs2 homology search.'''

    results = load_mmseqs(os.path.join(DATA_DIR, 'mmseqs', 'results_s_default'))
    controls = load_mmseqs(os.path.join(DATA_DIR, 'mmseqs', 'controls_s_default'))

    print('Total hits:', len(results))
    print('Total hits (controls):', len(controls))

    print('Total hits spanning putative selenocysteine:', results.past_stop_codon.sum())
    for gene_id in set(results.query_gene_id):
        gene_id_results = results[results.query_gene_id == gene_id]
        alignment_length = gene_id_results.alignment_length.mean()
        aa_ext = gene_id_results.query_aa_ext.iloc[0]
        print(f'\t{gene_id}:', len(results[results.query_gene_id == gene_id]), f'(mean alignment length: {int(alignment_length)}, extension length: {aa_ext})')



def mmseqs_plot_hits(data:pd.DataFrame, query_gene_id:str, past_stop_codon:bool=False) -> NoReturn:
    '''Visualize the homology hits on the query sequence.'''

    if past_stop_codon:
        data = data[data.past_stop_codon]

    fig, ax = plt.subplots(1)
    assert query_gene_id in data.query_gene_id.values, f'homology.plot_hits_past_stop_codon: {query_gene_id} is not present in the data.'

    data = data[data.query_gene_id.str.match(query_gene_id)]
    u_loc = data.query_u_position.iloc[0] # Get the location of the putative selenocysteine residue. 

    locs = np.arange(data.query_aa_length.iloc[0])
    locs_labels = ['' if (l != u_loc) else 'U' for l in locs]

    for d in [data[~data.control], data[data.control]]:
        hits = {i:0 for i in locs} # Create a map from amino acid position to number of hits. 
        for hit in d.itertuples():
            for loc in range(hit.query_domain_start, hit.query_domain_stop + 1):
                hits[loc] += 1
        ax.plot(locs, [hits[x] for x in locs])

    ax.legend(['result', 'control'])
    ax.set_title(query_gene_id if not past_stop_codon else f'{query_gene_id} (hits past stop codon)')
    ax.set_xticks(locs)
    ax.set_xticklabels(locs_labels)
    ax.set_xlabel('residue position')
    ax.set_ylabel('hits')

    plt.savefig(f'{query_gene_id}.png' if not past_stop_codon else f'{query_gene_id}_past_stop_codon.png', format='PNG')
    

def ncbi_blast_find_hits_past_stop_codon():

    u_pos = {'ydhv':701, 'ygdt':49}

    data = load_ncbi_blast()
    data = data[data.apply(lambda row : len(row.seq) > u_pos[row.query_gene_id], axis=1)]
    data['length'] = data.seq.apply(len)
    
    print(data.length)






# The goal is to find hits which are in the region after the stop codon of the predicted proteins, but don't overlap with the next protein. 
if __name__ == '__main__':
    ncbi_blast_find_hits_past_stop_codon()


# Why did I get hits for ygdT in this iteration and not the other?
    

