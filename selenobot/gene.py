'''Utilities for managing genome files and sequences. These are designed to work
for GTDB files, which are generated by Prodigal (so any Prodigal output should work).'''

from selenobot.files import FASTAFile, GBFFFile
import pandas as pd 
import numpy as np 
from Bio.Seq import Seq
from typing import Dict

# TODO: Make an option to load this from a GBFF file. 
class Genome():

    def __init__(self, contigs:Dict[str, str]):
        # Maps the contig ID to the contig sequence, NOT a contig number.
        self.contigs = contigs
        self.n_contigs = len(contigs) 
        self.contig_ids = list(contigs.keys())
        self.complete = (len(self.contigs) == 1)

    @classmethod
    def from_fasta(cls, path:str):

        file = FASTAFile(path)
        df = file.to_df()
        contigs = {id_:contig for id_, contig in zip(fasta_df.index, fasta_df.seq)}
        return cls(contigs)
    
    @classmethod
    def from_gbff(cls, path:str):
        
        file = GBFFFile(path, load_nt_seqs=True)
        return cls(file.contigs)


class Gene():
    '''A construct for managing genes. This assumes that the gene is complete, i.e. not partial.'''

    start_codons = ['ATG', 'GTG', 'TTG']
    stop_codons = ['TAA', 'TAG', 'TGA'] 

    @staticmethod
    def reverse_complement(seq:str) -> str:
        '''Converts the input DNA strand to its reverse complement.'''
        return str(Seq(seq).reverse_complement())

    def __init__(self, gene_id:str, genome:Genome, stop:int=None, start:int=None, strand:int=None):

        assert (stop - start) % 3 == 0, f'Gene.__init__: The input sequence {gene_id} is not divisible by three.' 
        
        self.gene_id = gene_id 
        self.genome = genome
        self.contig_id = '_'.join(gene_id.split('_')[:-1])
        contig = genome.contigs[self.contig_id]
        self.contig = Gene.reverse_complement(contig) if (strand < 0) else contig

        self.length = stop - start 
        self.start = start if (strand > 0) else (len(self.contig) - stop)

        self.strand = strand
        
        self.seq = self.contig[self.start:self.start + self.length]
        self.start_codon = self.seq[:3] 
        self.stop_codon = self.seq[-3:]

        self.original_length = None
        self.original_stop_codon = None 
        self.extension_size = None

    def check(self):
        assert len(self) % 3 == 0, 'Gene.check: The nucleotide sequence is not divisible by three.'
        assert self.stop_codon in Gene.stop_codons, f'Gene.check: The stop codon {self.stop_codon} is invalid.'
        assert self.start_codon in Gene.start_codons, f'Gene.check: The start codon {self.start_codon} is invalid.'

    def __str__(self):
        return self.seq

    def __eq__(self, gene):
        '''Define equality between two sequence objects to mean (1) the sequences match and (2) the IDs match.'''
        return (self.gene_id == seq.gene_id) and (self.seq == gene.seq)

    def __len__(self):
        return self.length
    
    def info(self, seq_type:str='aa', translation_table:int=11):
        fields = ['gene_id', 'strand', 'original_length', 'extension_size', 'original_stop_codon', 'stop_codon', 'start_codon', 'seq']
        info = dict()
        for field in fields:
            if (field == 'seq') and (seq_type == 'aa'):
                info[field] = self.translate(translation_table=translation_table)
            else:
                info[field] = getattr(self, field)
        return info

    def translate(self, translation_table:int=11):
        '''Translate a nucleotide sequence to amino acids.'''
        # Can't set cds=True because it throws an error with in-frame stop codons. 
        seq = str(Seq(self.seq).translate(to_stop=False, table=translation_table))
        # assert seq[-1] == '*', 'Gene.translate: The last symbol in the amino acid sequence should be *, indicating a translational stop.'
        seq = seq[:-1] # Remove the terminal * character. 
        seq = str(seq).replace('*', 'U') # Replace the in-frame stops with selenocysteine.
        # seq = 'M' + seq[1:] # Not sure why this is always methionine in NCBI, but doesn't always get translated as M. 
        return seq

    def extend(self, error:str='raise'):
        '''Extend the gene to the next valid stop codon.''' 

        idx, ext, success = self.start + self.length, 0, False
        while idx + 3 < len(self.contig):
            next_codon = self.contig[idx:idx + 3]
            idx += 3
            ext += 3
            if next_codon in Gene.stop_codons:
                success = True
                break
        
        if (error == 'raise'):
            assert success, 'Gene.extend: Unable to find a stop codon in the downstream region.'
        elif (error == 'ignore') and (not success):
            ext = 0

        if self.strand < 0:
            new_start = len(self.contig) - self.start - self.length - ext
            new_stop = len(self.contig) - self.start
        else:
            new_start = self.start 
            new_stop = self.start + self.length + ext

        new_gene = Gene(self.gene_id, self.genome, start=new_start, stop=new_stop, strand=self.strand)
        new_gene.original_length = self.length 
        new_gene.original_stop_codon = self.stop_codon
        new_gene.extension_size = ext

        return new_gene






        






