'''Utility functions for reading and writing FASTA and CSV files, amongst other things.'''
import pandas as pd
import numpy as np
import os
from tqdm import tqdm
import re
from typing import Dict, NoReturn
import configparser
import pickle
import subprocess


def write(text:str, path:str) -> NoReturn:
    '''Writes a string of text to a file.   
    
    :param text: The text to write to the file.
    :param path: The path of the file to which the text will be written. 
    '''
    if path is not None:
        with open(path, 'w') as f:
            f.write(text)


def read(path:str) -> str:
    '''Reads the information contained in a text file into a string.
    
    :param path: The path to the file to read. 
    :return: The text contained in the file as a Python string.
    '''
    with open(path, 'r') as f: #, encoding='UTF-8') as f:
        text = f.read()
    return text


def get_id(head:str) -> str:
    '''Extract the unique identifier from a FASTA metadata string (the information on the line preceding 
    the actual sequence). This ID should be flanked by '|' characters.
    '''
    start_idx = head.find('|') + 1
    # Cut off any extra stuff preceding the ID, and locate the remaining |.
    head = head[start_idx:]
    end_idx = head.find('|')
    return head[:end_idx]


def fasta_ids(path, get_id_func=get_id):
    '''Extract all gene IDs stored in a FASTA file.'''
    # Read in the FASTA file as a string. 
    fasta = read(path)
    # Extract all the IDs from the headers, and return the result. 
    ids = [get_id_func(head) for head in re.findall(r'^>.*', fasta, re.MULTILINE)]
    return np.array(ids)


def csv_size(path):
    '''Get the number of entries in a CSV file.'''
    n = subprocess.run(f'wc -l {path}', capture_output=True, text=True, shell=True, check=True).stdout.split()[0]
    n = int(n) - 1 # Convert text output to an integer and disregard the header row.
    return n


def fasta_seqs(path):
    '''Extract all amino acid sequences stored in a FASTA file.'''
    # Read in the FASTA file as a string. 
    fasta = read(path)
    seqs = re.split(r'^>.*', fasta, flags=re.MULTILINE)[1:]
    # Strip all of the newline characters from the amino acid sequences. 
    seqs = [s.replace('\n', '') for s in seqs]
    # return np.array(seqs)
    return seqs
    

def fasta_size(path):
    '''Get the number of entries in a FASTA file.'''
    return len(fasta_ids(path))


def fasta_concatenate(paths, out_path=None):
    '''Combine the FASTA files specified by the paths. Creates a new file
    containing the combined data.'''
    dfs = [pd_from_fasta(p, set_index=False) for p in paths]
    df = pd.concat(dfs)
    
    # Remove any duplicates following concatenation. 
    n = len(df)
    df = df.drop_duplicates(subset='id')
    df = df.set_index('id')

    if len(df) < n:
        print(f'utils.fasta_concatenate: {n - len(df)} duplicates removed upon concatenation.')

    pd_to_fasta(df, path=out_path)


def dataframe_from_fasta(path, set_index=False, get_id_func=get_id):
    '''Load a FASTA file in as a pandas DataFrame.'''

    ids = fasta_ids(path, get_id_func=get_id_func)
    seqs = fasta_seqs(path)

    df = pd.DataFrame({'seq':seqs, 'id':ids})
    # df = df.astype({'id':str, 'seq':str})
    if set_index: 
        df = df.set_index('id')
    return df


def dataframe_to_fasta(df:pd.DataFrame, path:str, textwidth:int=80) -> NoReturn:
    '''Convert a pandas DataFrame containing FASTA data to a FASTA file format.

    :param df: The pandas DataFrame containing, at minimum, a column of sequences and
        a column of gene IDs.
    :param path: The path to write the FASTA file to. 
    :param textwidth: The length of lines in the FASTA file.     
    '''
    # assert df.index.name == 'id', 'utils.pd_to_fasta: Gene ID must be set as the DataFrame index before writing.'
    fasta = ''
    for row in df.itertuples():
        fasta += '>|' + str(row.Index) + '|\n'
        # Split the sequence up into substrings of length textwidth.
        n = len(row.seq)
        seq = [row.seq[i:min(n, i + textwidth)] for i in range(0, n, textwidth)]
        assert len(''.join(seq)) == n, 'utils.pd_to_fasta: Part of the sequence was lmicrobiologyost when splitting into lines.'
        fasta += '\n'.join(seq) + '\n'
    # Write the FASTA string to the path-specified file. 
    write(fasta, path=path)


def dataframe_from_clstr(path:str) -> pd.DataFrame:
    '''Convert a .clstr file string to a pandas DataFrame. 
    
    :param path: The path to the .clstr file generated by CD-HIT.
    :return: A pandas DataFrame mapping gene ID to cluster ID. 
    '''
    clstr = read(clstr_file_path) # Read in the cluster file as a string. 
    df = {'id':[], 'cluster':[]}
    # The start of each new cluster is marked with a line like ">Cluster [num]"
    clusters = re.split(r'^>.*', clstr, flags=re.MULTILINE)
    # Split on the newline. 
    for i, cluster in enumerate(clusters):
        ids = [get_id(x) for x in cluster.split('\n') if x != '']
        df['id'] += ids
        df['cluster'] += [i] * len(ids)

    df = pd.DataFrame(df) # .set_index('id')
    df.cluster = df.cluster.astype(int) # This will speed up grouping clusters later on. 
    return df








